---
title: Hash算法及相关应用
date: 2020-11-30 10:11:01
cover: images/hash.jpg
photos: 
  -  images/hash.jpg
categories: 
  - 加密传输技术 
tags: 
  - https
  - 文章
---
本文主要简单介绍Hash算法的原理，种类和一些应用举例
<!--more -->

# **一、什么是Hash算法**
Hash算法又称散列算法，特点是**把任意长度的输入，通过散列算法变成固定长度的输出，这个输出即散列值**（即是某种映射关系），
由于散列值得空间远小于输入空间，因此存在不同输入得到相同的散列值，这种现象称为**碰撞**。  
特性：**同一散列算法，散列值不同，输入肯定不同，反之则不一定成立**。

# **二、常见的Hash函数（算法）**
## **基本算法**

目前业界有很多Hash算法，其算法核心基本可以归纳下面几种算法的组合

```java
// 由于篇幅原因，主要介绍碰撞解决方案的基本原理，详细请自行查阅
1.直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址
2.数字分析法：提取关键字中取值比较均匀的数字作为哈希地址
3.除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址
4.分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址
5.平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址
6.伪随机数法：采用一个伪随机数当作哈希函数
```

衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及解决方案，任何Hash函数都无法避免碰撞，以下是常见的一些碰撞的解决方法：

```java
// 由于篇幅原因，主要介绍碰撞解决方案的基本原理，详细请自行查阅
1.开放地址法：开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入
2.链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部
3.再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止
4.建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中
```

## **举例说明**

哈希算法为了提高效率并且减少其碰撞的概率，不断改进，诞生了很多哈希算法。下面列举了部分应用较为广泛的哈希算法：

# 三、**Hash函数的应用**

## **1. HashMap**

Java中有两种常见的数据结构 **数组** 和 **链表**
```
数组:寻址容易，插入和删除困难

链表:寻址困难，插入和删除容易
```
上面提到哈希算法的其中一种解决冲突的方式——链地址法，就是将这两种数据结构相结合，发挥各自的优势(可以简单理解为链表数组)

![](p1.png)
可以很清楚地看到，左边是数组，其中每个成员均由链表组成。我们通过某种方式计算元素的特征值，也就是获取数组的下标，从而找到了正确的链表，再从链表中找到正确的元素。**这个计算特征值的方法就是哈希算法**。

```
final int hash(Object k) {
    int h = hashSeed;
    if (0 != h && k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }
 
    h ^= k.hashCode();
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}

```
在JDK1.7中，HashMap的源码正是采用了这种方法来存储对象。HashMap中有一个hash(key)方法，它的作用就是根据key来定位这个元素在链表数组的下标，该方法返回的是个int类型的数值，那应该怎么计算这个int值并且尽可能的不重复呢？


```
public class Object {
    public Object() {
    }

    private static native void registerNatives();

    public final native Class<?> getClass();

    public native int hashCode();

    ...
}
```
我们都知道，Object类都会有一个hashCode方法，这个方法会将对象进行哈希运算，得到该对象的“标签”，这个标签有**一定程度**的唯一性，因此可以用hashCode方法来计算HashMap中hash方法的返回。事实上，HashMap也是这样实现的，不过，还对key的hashCode做了一些扰动处理，降低了"碰撞"的概率。

未完待续...(详细讲一下HashMap的hash方法——取模，扰动过程以及HashMap1.8)

参考文章: [hash算法详解](https://blog.csdn.net/xu_dongdong/article/details/80251936)